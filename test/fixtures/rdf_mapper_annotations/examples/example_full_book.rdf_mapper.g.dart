// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/rdf_mapper_annotations/examples/example_full_book.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'example_full_book.dart';
import 'package:rdf_vocabularies/schema.dart';
import 'package:rdf_vocabularies/rdf.dart' as rdf;

/// Generated mapper for [String] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type String.
class BookAuthorIdMapper implements IriTermMapper<String> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/author/(?<authorId>[^/]*)\$',
  );

  /// Constructor
  const BookAuthorIdMapper();

  @override
  String fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    return iriParts['authorId']!;
  }

  @override
  IriTerm toRdfTerm(
    String iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final authorId = iriTermValue.toString();
    return IriTerm('http://example.org/author/${authorId}');
  }
}

/// Generated mapper for [Book] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type Book.
class BookMapper implements GlobalResourceMapper<Book> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/book/(?<id>[^/]*)\$',
  );

  final IriTermMapper<String> _authorIdMapper;

  /// Constructor
  const BookMapper({
    IriTermMapper<String> authorIdMapper = const BookAuthorIdMapper(),
  }) : _authorIdMapper = authorIdMapper;

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  Book fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.iri);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id']!;
    final String title = reader.require(SchemaBook.name);
    final String authorId = reader.require(
      SchemaBook.author,
      iriTermDeserializer: _authorIdMapper,
    );
    final DateTime published = reader.require(SchemaBook.datePublished);
    final ISBN isbn = reader.require(SchemaBook.isbn);
    final Rating rating = reader.require(SchemaBook.aggregateRating);
    final Iterable<Chapter> chapters = reader.getValues<Chapter>(
      SchemaBook.hasPart,
    );

    return Book(
      id: id,
      title: title,
      authorId: authorId,
      published: published,
      isbn: isbn,
      rating: rating,
      chapters: chapters,
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addValue(
          SchemaBook.author,
          resource.authorId,
          iriTermSerializer: _authorIdMapper,
        )
        .addValue(SchemaBook.datePublished, resource.published)
        .addValue(SchemaBook.isbn, resource.isbn)
        .addValue(SchemaBook.aggregateRating, resource.rating)
        .addValues<Chapter>(SchemaBook.hasPart, resource.chapters)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Book resource) {
    final id = resource.id;
    return 'http://example.org/book/${id}';
  }
}

/// Generated mapper for [Chapter] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type Chapter.
class ChapterMapper implements LocalResourceMapper<Chapter> {
  /// Constructor
  const ChapterMapper();

  @override
  IriTerm? get typeIri => SchemaChapter.classIri;

  @override
  Chapter fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String title = reader.require(SchemaChapter.name);
    final int number = reader.require(SchemaChapter.position);

    return Chapter(title, number);
  }

  @override
  (BlankNodeTerm, List<Triple>) toRdfResource(
    Chapter resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(SchemaChapter.name, resource.title)
        .addValue(SchemaChapter.position, resource.number)
        .build();
  }
}

/// Generated mapper for [ISBN] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type ISBN.
class ISBNMapper implements IriTermMapper<ISBN> {
  static final RegExp _regex = RegExp('^urn:isbn:(?<value>[^/]*)\$');

  /// Constructor
  const ISBNMapper();

  @override
  ISBN fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['value']!;

    return ISBN(value);
  }

  @override
  IriTerm toRdfTerm(
    ISBN iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    return IriTerm('urn:isbn:${value}');
  }
}

/// Generated mapper for [Rating] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Rating.
class RatingMapper implements LiteralTermMapper<Rating> {
  const RatingMapper();

  @override
  Rating fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    final int stars = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck: bypassDatatypeCheck,
    );

    return Rating(stars);
  }

  @override
  LiteralTerm toRdfTerm(
    Rating value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.stars);
  }
}
