// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/rdf_mapper_annotations/examples/custom_collection_type_example.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'custom_collection_type_example.dart';

/// Generated mapper for [Library] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Library`.
class LibraryMapper implements GlobalResourceMapper<Library> {
  static final RegExp _regex = RegExp(r'^(?<baseUri>.*)/library/(?<id>[^/]*)$');

  final String Function() _baseUriProvider;

  /// Constructor
  const LibraryMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => CollectionVocab.Library;

  @override
  Library fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final ImmutableList<String> collaborators = reader
        .requireCollection<ImmutableList<String>, String>(
          CollectionVocab.collaborators,
          ImmutableListMapperRdfList.new,
        );
    final ImmutableList<String> tags = reader
        .requireCollection<ImmutableList<String>, String>(
          CollectionVocab.tags,
          ImmutableListMapperRdfSeq.new,
        );
    final ImmutableList<String> members = reader
        .requireCollection<ImmutableList<String>, String>(
          CollectionVocab.members,
          ImmutableListMapperUnorderedItems.new,
        );

    final retval = Library();
    retval.id = id;
    retval.collaborators = collaborators;
    retval.tags = tags;
    retval.members = members;
    return retval;
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Library resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addCollection<ImmutableList<String>, String>(
          CollectionVocab.collaborators,
          resource.collaborators,
          ImmutableListMapperRdfList.new,
        )
        .addCollection<ImmutableList<String>, String>(
          CollectionVocab.tags,
          resource.tags,
          ImmutableListMapperRdfSeq.new,
        )
        .addCollection<ImmutableList<String>, String>(
          CollectionVocab.members,
          resource.members,
          ImmutableListMapperUnorderedItems.new,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Library resource) {
    final id = resource.id;
    final baseUri = _baseUriProvider();
    return '${baseUri}/library/${id}';
  }
}
