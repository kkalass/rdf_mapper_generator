// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/rdf_mapper_annotations/examples/enum_mapping_simple.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'enum_mapping_simple.dart';

/// Generated mapper for [Book] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `Book`.
class BookMapper implements GlobalResourceMapper<Book> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/books/(?<sku>[^/]*)$',
  );

  final LiteralTermMapper<Priority> _priorityMapper;
  final LiteralTermMapper<ProductStatus> _statusMapper;

  /// Constructor
  const BookMapper({
    required LiteralTermMapper<Priority> customPriorityMapper,
    LiteralTermMapper<ProductStatus> statusMapper =
        const LanguageOverrideMapper<ProductStatus>('en'),
  })  : _priorityMapper = customPriorityMapper,
        _statusMapper = statusMapper;

  @override
  IriTerm? get typeIri => MyBookVocab.classIri;

  @override
  Book fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.iri);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final sku = iriParts['sku']!;
    final BookFormat format = reader.require(MyBookVocab.bookFormat);
    final ItemCondition condition = reader.require(MyBookVocab.itemCondition);
    final Priority priority = reader.require(
      MyBookVocab.priority,
      deserializer: _priorityMapper,
    );
    final ProductStatus status = reader.require(
      MyBookVocab.status,
      deserializer: _statusMapper,
    );

    return Book(
      sku: sku,
      format: format,
      condition: condition,
      priority: priority,
      status: status,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(MyBookVocab.bookFormat, resource.format)
        .addValue(MyBookVocab.itemCondition, resource.condition)
        .addValue(
          MyBookVocab.priority,
          resource.priority,
          serializer: _priorityMapper,
        )
        .addValue(
          MyBookVocab.status,
          resource.status,
          serializer: _statusMapper,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Book resource) {
    final sku = resource.sku;
    return 'http://example.org/books/${sku}';
  }
}

/// Generated mapper for [BookFormat] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type BookFormat.
class BookFormatMapper implements LiteralTermMapper<BookFormat> {
  final IriTerm? datatype = null;

  const BookFormatMapper();

  @override
  BookFormat fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) =>
      switch (term.value) {
        'hardcover' => BookFormat.hardcover,
        'paperback' => BookFormat.paperback,
        'ebook' => BookFormat.ebook,
        _ => throw DeserializationException(
            'Unknown BookFormat literal value: ${term.value}',
          ),
      };

  @override
  LiteralTerm toRdfTerm(
    BookFormat value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        BookFormat.hardcover => LiteralTerm('hardcover'),
        BookFormat.paperback => LiteralTerm('paperback'),
        BookFormat.ebook => LiteralTerm('ebook'),
      };
}

/// Generated mapper for [Priority] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type Priority.
class PriorityMapper implements LiteralTermMapper<Priority> {
  final IriTerm? datatype = null;

  const PriorityMapper();

  @override
  Priority fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) =>
      switch (term.value) {
        'H' => Priority.high,
        'M' => Priority.medium,
        'L' => Priority.low,
        _ => throw DeserializationException(
            'Unknown Priority literal value: ${term.value}',
          ),
      };

  @override
  LiteralTerm toRdfTerm(
    Priority value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        Priority.high => LiteralTerm('H'),
        Priority.medium => LiteralTerm('M'),
        Priority.low => LiteralTerm('L'),
      };
}

/// Generated mapper for [ProductStatus] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type ProductStatus.
class ProductStatusMapper implements LiteralTermMapper<ProductStatus> {
  final IriTerm? datatype = null;

  const ProductStatusMapper();

  @override
  ProductStatus fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) =>
      switch (term.value) {
        'available' => ProductStatus.inStock,
        'sold-out' => ProductStatus.outOfStock,
        'discontinued' => ProductStatus.discontinued,
        _ => throw DeserializationException(
            'Unknown ProductStatus literal value: ${term.value}',
          ),
      };

  @override
  LiteralTerm toRdfTerm(
    ProductStatus value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        ProductStatus.inStock => LiteralTerm('available'),
        ProductStatus.outOfStock => LiteralTerm('sold-out'),
        ProductStatus.discontinued => LiteralTerm('discontinued'),
      };
}

/// Generated mapper for [ItemCondition] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type ItemCondition.
class ItemConditionMapper implements IriTermMapper<ItemCondition> {
  static final RegExp _regex = RegExp(r'^http://schema\.org/(?<value>[^/]*)$');

  /// Constructor
  const ItemConditionMapper();

  @override
  ItemCondition fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    if (match == null) {
      throw DeserializationException('Unknown ItemCondition IRI: ${term.iri}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value']!;

    return switch (enumValue) {
      'NewCondition' => ItemCondition.brandNew,
      'UsedCondition' => ItemCondition.used,
      'refurbished' => ItemCondition.refurbished,
      _ => throw DeserializationException(
          'Unknown ItemCondition IRI: ${term.iri}',
        ),
    };
  }

  @override
  IriTerm toRdfTerm(
    ItemCondition value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        ItemCondition.brandNew => IriTerm(_buildIri('NewCondition')),
        ItemCondition.used => IriTerm(_buildIri('UsedCondition')),
        ItemCondition.refurbished => IriTerm(_buildIri('refurbished')),
      };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://schema.org/${value}';
  }
}

/// Generated mapper for [OrderStatus] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type OrderStatus.
class OrderStatusMapper implements IriTermMapper<OrderStatus> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/vocab/order-status/(?<value>[^/]*)$',
  );

  /// Constructor
  const OrderStatusMapper();

  @override
  OrderStatus fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    if (match == null) {
      throw DeserializationException('Unknown OrderStatus IRI: ${term.iri}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value']!;

    return switch (enumValue) {
      'pending' => OrderStatus.pending,
      'in-progress' => OrderStatus.processing,
      'shipped' => OrderStatus.shipped,
      'delivered-completed' => OrderStatus.delivered,
      _ => throw DeserializationException(
          'Unknown OrderStatus IRI: ${term.iri}',
        ),
    };
  }

  @override
  IriTerm toRdfTerm(
    OrderStatus value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        OrderStatus.pending => IriTerm(_buildIri('pending')),
        OrderStatus.processing => IriTerm(_buildIri('in-progress')),
        OrderStatus.shipped => IriTerm(_buildIri('shipped')),
        OrderStatus.delivered => IriTerm(_buildIri('delivered-completed')),
      };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://example.org/vocab/order-status/${value}';
  }
}

/// Generated mapper for [CurrencyCode] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type CurrencyCode.
class CurrencyCodeMapper implements LiteralTermMapper<CurrencyCode> {
  final IriTerm? datatype = null;

  const CurrencyCodeMapper();

  @override
  CurrencyCode fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) =>
      switch (term.value) {
        'USD' => CurrencyCode.usDollar,
        'EUR' => CurrencyCode.euro,
        'GBP' => CurrencyCode.britishPound,
        'JPY' => CurrencyCode.japaneseYen,
        _ => throw DeserializationException(
            'Unknown CurrencyCode literal value: ${term.value}',
          ),
      };

  @override
  LiteralTerm toRdfTerm(
    CurrencyCode value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        CurrencyCode.usDollar => LiteralTerm('USD'),
        CurrencyCode.euro => LiteralTerm('EUR'),
        CurrencyCode.britishPound => LiteralTerm('GBP'),
        CurrencyCode.japaneseYen => LiteralTerm('JPY'),
      };
}

/// Generated mapper for [BusinessEntityType] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type BusinessEntityType.
class BusinessEntityTypeMapper implements IriTermMapper<BusinessEntityType> {
  static final RegExp _regex = RegExp(
    r'^http://purl\.org/goodrelations/v1#(?<value>[^/]*)$',
  );

  /// Constructor
  const BusinessEntityTypeMapper();

  @override
  BusinessEntityType fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    if (match == null) {
      throw DeserializationException(
        'Unknown BusinessEntityType IRI: ${term.iri}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value']!;

    return switch (enumValue) {
      'Business' => BusinessEntityType.business,
      'Enduser' => BusinessEntityType.endUser,
      'PublicInstitution' => BusinessEntityType.publicInstitution,
      'Reseller' => BusinessEntityType.reseller,
      _ => throw DeserializationException(
          'Unknown BusinessEntityType IRI: ${term.iri}',
        ),
    };
  }

  @override
  IriTerm toRdfTerm(
    BusinessEntityType value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        BusinessEntityType.business => IriTerm(_buildIri('Business')),
        BusinessEntityType.endUser => IriTerm(_buildIri('Enduser')),
        BusinessEntityType.publicInstitution => IriTerm(
            _buildIri('PublicInstitution'),
          ),
        BusinessEntityType.reseller => IriTerm(_buildIri('Reseller')),
      };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://purl.org/goodrelations/v1#${value}';
  }
}

/// Generated mapper for [UserRating] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type UserRating.
class UserRatingMapper implements IriTermMapper<UserRating> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/rating-system/(?<value>[^/]*)$',
  );

  /// Constructor
  const UserRatingMapper();

  @override
  UserRating fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    if (match == null) {
      throw DeserializationException('Unknown UserRating IRI: ${term.iri}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value']!;

    return switch (enumValue) {
      'excellent-5-stars' => UserRating.excellent,
      'good-4-stars' => UserRating.good,
      'average-3-stars' => UserRating.average,
      'poor-2-stars' => UserRating.poor,
      'terrible-1-star' => UserRating.terrible,
      _ => throw DeserializationException(
          'Unknown UserRating IRI: ${term.iri}',
        ),
    };
  }

  @override
  IriTerm toRdfTerm(
    UserRating value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        UserRating.excellent => IriTerm(_buildIri('excellent-5-stars')),
        UserRating.good => IriTerm(_buildIri('good-4-stars')),
        UserRating.average => IriTerm(_buildIri('average-3-stars')),
        UserRating.poor => IriTerm(_buildIri('poor-2-stars')),
        UserRating.terrible => IriTerm(_buildIri('terrible-1-star')),
      };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://example.org/rating-system/${value}';
  }
}

/// Generated mapper for [ProductCategory] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type ProductCategory.
class ProductCategoryMapper implements IriTermMapper<ProductCategory> {
  static final RegExp _regex = RegExp(
    r'^(?<baseVocab>.*)/categories/(?<value>[^/]*)$',
  );

  final String Function() _baseVocabProvider;

  /// Constructor
  const ProductCategoryMapper({required String Function() baseVocabProvider})
      : _baseVocabProvider = baseVocabProvider;

  @override
  ProductCategory fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    if (match == null) {
      throw DeserializationException(
        'Unknown ProductCategory IRI: ${term.iri}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value']!;

    return switch (enumValue) {
      'electronics' => ProductCategory.electronics,
      'books-media' => ProductCategory.booksAndMedia,
      'clothing' => ProductCategory.clothing,
      'home-garden' => ProductCategory.homeAndGarden,
      _ => throw DeserializationException(
          'Unknown ProductCategory IRI: ${term.iri}',
        ),
    };
  }

  @override
  IriTerm toRdfTerm(
    ProductCategory value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        ProductCategory.electronics => IriTerm(_buildIri('electronics')),
        ProductCategory.booksAndMedia => IriTerm(_buildIri('books-media')),
        ProductCategory.clothing => IriTerm(_buildIri('clothing')),
        ProductCategory.homeAndGarden => IriTerm(_buildIri('home-garden')),
      };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    final baseVocab = _baseVocabProvider();
    return '${baseVocab}/categories/${value}';
  }
}

/// Generated mapper for [ShippingMethod] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type ShippingMethod.
class ShippingMethodMapper implements IriTermMapper<ShippingMethod> {
  static final RegExp _regex = RegExp(
    r'^(?<apiBase>.*)/(?<version>[^/]*)/shipping-methods/(?<value>[^/]*)$',
  );

  final String Function() _apiBaseProvider;
  final String Function() _versionProvider;

  /// Constructor
  const ShippingMethodMapper({
    required String Function() apiBaseProvider,
    required String Function() versionProvider,
  })  : _apiBaseProvider = apiBaseProvider,
        _versionProvider = versionProvider;

  @override
  ShippingMethod fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    if (match == null) {
      throw DeserializationException('Unknown ShippingMethod IRI: ${term.iri}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value']!;

    return switch (enumValue) {
      'standard' => ShippingMethod.standard,
      'express-overnight' => ShippingMethod.express,
      'same-day-delivery' => ShippingMethod.sameDay,
      'pickup-in-store' => ShippingMethod.pickup,
      _ => throw DeserializationException(
          'Unknown ShippingMethod IRI: ${term.iri}',
        ),
    };
  }

  @override
  IriTerm toRdfTerm(
    ShippingMethod value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        ShippingMethod.standard => IriTerm(_buildIri('standard')),
        ShippingMethod.express => IriTerm(_buildIri('express-overnight')),
        ShippingMethod.sameDay => IriTerm(_buildIri('same-day-delivery')),
        ShippingMethod.pickup => IriTerm(_buildIri('pickup-in-store')),
      };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    final apiBase = _apiBaseProvider();
    final version = _versionProvider();
    return '${apiBase}/${version}/shipping-methods/${value}';
  }
}

/// Generated mapper for [EmployeeRole] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type EmployeeRole.
class EmployeeRoleMapper implements IriTermMapper<EmployeeRole> {
  static final RegExp _regex = RegExp(
    r'^(?<orgNamespace>.*)/departments/(?<department>[^/]*)/roles/(?<value>[^/]*)$',
  );

  final String Function() _departmentProvider;
  final String Function() _orgNamespaceProvider;

  /// Constructor
  const EmployeeRoleMapper({
    required String Function() departmentProvider,
    required String Function() orgNamespaceProvider,
  })  : _departmentProvider = departmentProvider,
        _orgNamespaceProvider = orgNamespaceProvider;

  @override
  EmployeeRole fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    if (match == null) {
      throw DeserializationException('Unknown EmployeeRole IRI: ${term.iri}');
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value']!;

    return switch (enumValue) {
      'manager' => EmployeeRole.manager,
      'team-lead' => EmployeeRole.teamLead,
      'developer' => EmployeeRole.developer,
      'quality-assurance' => EmployeeRole.qualityAssurance,
      _ => throw DeserializationException(
          'Unknown EmployeeRole IRI: ${term.iri}',
        ),
    };
  }

  @override
  IriTerm toRdfTerm(
    EmployeeRole value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) =>
      switch (value) {
        EmployeeRole.manager => IriTerm(_buildIri('manager')),
        EmployeeRole.teamLead => IriTerm(_buildIri('team-lead')),
        EmployeeRole.developer => IriTerm(_buildIri('developer')),
        EmployeeRole.qualityAssurance =>
          IriTerm(_buildIri('quality-assurance')),
      };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    final orgNamespace = _orgNamespaceProvider();
    final department = _departmentProvider();
    return '${orgNamespace}/departments/${department}/roles/${value}';
  }
}
