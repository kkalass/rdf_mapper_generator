// GENERATED CODE - DO NOT MODIFY BY HAND
// 
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/annotation_test_models.dart
// Generated on: 2025-06-03T10:39:19.770402

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';
import 'package:rdf_vocabularies/schema.dart';
import 'annotation_test_models.dart';

/// Generated mapper for [BookWithMapper] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type BookWithMapper.
class BookWithMapperMapper implements GlobalResourceMapper<BookWithMapper> {
  @override
  IriTerm get typeIri => SchemaBook.classIri;

  @override
  BookWithMapper fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    

    return BookWithMapper(
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    BookWithMapper resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm('');
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

}


/// Generated mapper for [BookWithMapperInstance] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type BookWithMapperInstance.
class BookWithMapperInstanceMapper implements GlobalResourceMapper<BookWithMapperInstance> {
  @override
  IriTerm get typeIri => SchemaBook.classIri;

  @override
  BookWithMapperInstance fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    

    return BookWithMapperInstance(
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    BookWithMapperInstance resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm('');
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

}


/// Generated mapper for [BookWithTemplate] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type BookWithTemplate.
class BookWithTemplateMapper implements GlobalResourceMapper<BookWithTemplate> {
  @override
  IriTerm get typeIri => SchemaBook.classIri;

  @override
  BookWithTemplate fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri, 'https://example.org/books/{id}', 
    ['id']);
    

    return BookWithTemplate(
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    BookWithTemplate resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(BookWithTemplate resource) {
    var iri = '{template: https://example.org/books/{id}, variables: [{value: id, last: true}], propertyVariables: [{value: id, last: true}], contextVariables: []}';
    return iri;
  }

   /// Parses IRI parts from a complete IRI using the template.
  Map<String, String> _parseIriParts(String iri, String template, List<String> variables) {
    final parts = <String, String>{};
    
    // Handle case where iri doesn't match the expected pattern
    if (!iri.startsWith(template.split('{').first)) {
      return parts;
    }
    
    // Create regex pattern from template
    String pattern = template;
    for (final variable in variables) {
      pattern = pattern.replaceAll('{$variable}', '([^/]+)');
    }
    pattern = '^${pattern}\$';
    
    // Extract values using regex
    final regex = RegExp(pattern);
    final match = regex.firstMatch(iri);
    
    if (match != null) {
      for (int i = 0; i < variables.length; i++) {
        // Regex groups start at index 1
        parts[variables[i]] = match.group(i + 1) ?? '';
      }
    }
    
    return parts;
  }
}


