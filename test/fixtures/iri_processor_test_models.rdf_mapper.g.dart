// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/iri_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'iri_processor_test_models.dart';

/// Generated mapper for [IriWithOnePart] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithOnePart.
class IriWithOnePartMapper implements IriTermMapper<IriWithOnePart> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/books/(?<isbn>[^/]*)\$',
  );

  /// Constructor
  const IriWithOnePartMapper();

  @override
  IriWithOnePart fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final isbn = iriParts['isbn']!;

    return IriWithOnePart(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePart resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = 'http://example.org/books/{isbn}';
    iri = iri.replaceAll('{isbn}', resource.isbn.toString());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithOnePartExplicitlyGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithOnePartExplicitlyGlobal.
class IriWithOnePartExplicitlyGlobalMapper
    implements IriTermMapper<IriWithOnePartExplicitlyGlobal> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/books/(?<isbn>[^/]*)\$',
  );

  /// Constructor
  const IriWithOnePartExplicitlyGlobalMapper();

  @override
  IriWithOnePartExplicitlyGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final isbn = iriParts['isbn']!;

    return IriWithOnePartExplicitlyGlobal(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePartExplicitlyGlobal resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = 'http://example.org/books/{isbn}';
    iri = iri.replaceAll('{isbn}', resource.isbn.toString());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithOnePartNamed] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithOnePartNamed.
class IriWithOnePartNamedMapper implements IriTermMapper<IriWithOnePartNamed> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/books/(?<isbn>[^/]*)\$',
  );

  /// Constructor
  const IriWithOnePartNamedMapper();

  @override
  IriWithOnePartNamed fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final value = iriParts['isbn']!;

    return IriWithOnePartNamed(value: value);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePartNamed resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = 'http://example.org/books/{isbn}';
    iri = iri.replaceAll('{isbn}', resource.value.toString());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithTwoParts] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithTwoParts.
class IriWithTwoPartsMapper implements IriTermMapper<IriWithTwoParts> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/(?<type>[^/]*)/(?<value>[^/]*)\$',
  );

  /// Constructor
  const IriWithTwoPartsMapper();

  @override
  IriWithTwoParts fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final value = iriParts['value']!;
    final type = iriParts['type']!;

    return IriWithTwoParts(value: value, type: type);
  }

  @override
  IriTerm toRdfTerm(
    IriWithTwoParts resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = 'http://example.org/{type}/{value}';
    iri = iri.replaceAll('{value}', resource.value.toString());
    iri = iri.replaceAll('{type}', resource.type.toString());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithBaseUriAndTwoParts] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithBaseUriAndTwoParts.
class IriWithBaseUriAndTwoPartsMapper
    implements IriTermMapper<IriWithBaseUriAndTwoParts> {
  static final RegExp _regex = RegExp(
    '^(?<baseUri>.*)/(?<type>[^/]*)/(?<value>[^/]*)\$',
  );

  /// Provider for context variable 'baseUri'
  final String Function() _baseUriProvider;

  /// Constructor requiring providers for context variables
  const IriWithBaseUriAndTwoPartsMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUriAndTwoParts fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final value = iriParts['value']!;
    final otherPart = iriParts['type']!;

    return IriWithBaseUriAndTwoParts(value: value, otherPart: otherPart);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUriAndTwoParts resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = '{+baseUri}/{type}/{value}';
    iri = iri.replaceAll('{value}', resource.value.toString());
    iri = iri.replaceAll('{type}', resource.otherPart.toString());
    iri = iri.replaceAll('{+baseUri}', _baseUriProvider());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithBaseUri] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithBaseUri.
class IriWithBaseUriMapper implements IriTermMapper<IriWithBaseUri> {
  static final RegExp _regex = RegExp('^(?<baseUri>.*)/books/(?<isbn>[^/]*)\$');

  /// Provider for context variable 'baseUri'
  final String Function() _baseUriProvider;

  /// Constructor requiring providers for context variables
  const IriWithBaseUriMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUri fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final isbn = iriParts['isbn']!;

    return IriWithBaseUri(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUri resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = '{+baseUri}/books/{isbn}';
    iri = iri.replaceAll('{isbn}', resource.isbn.toString());
    iri = iri.replaceAll('{+baseUri}', _baseUriProvider());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithBaseUriNoGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithBaseUriNoGlobal.
class IriWithBaseUriNoGlobalMapper
    implements IriTermMapper<IriWithBaseUriNoGlobal> {
  static final RegExp _regex = RegExp('^(?<baseUri>.*)/books/(?<isbn>[^/]*)\$');

  /// Provider for context variable 'baseUri'
  final String Function() _baseUriProvider;

  /// Constructor requiring providers for context variables
  const IriWithBaseUriNoGlobalMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUriNoGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final isbn = iriParts['isbn']!;

    return IriWithBaseUriNoGlobal(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUriNoGlobal resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = '{+baseUri}/books/{isbn}';
    iri = iri.replaceAll('{isbn}', resource.isbn.toString());
    iri = iri.replaceAll('{+baseUri}', _baseUriProvider());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithNonConstructorFields] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithNonConstructorFields.
class IriWithNonConstructorFieldsMapper
    implements IriTermMapper<IriWithNonConstructorFields> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/items/(?<id>[^/]*)\$',
  );

  /// Constructor
  const IriWithNonConstructorFieldsMapper();

  @override
  IriWithNonConstructorFields fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final id = iriParts['id']!;

    final retval = IriWithNonConstructorFields();
    retval.id = id;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithNonConstructorFields resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = 'http://example.org/items/{id}';
    iri = iri.replaceAll('{id}', resource.id.toString());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithNonConstructorFieldsAndBaseUriNonGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithNonConstructorFieldsAndBaseUriNonGlobal.
class IriWithNonConstructorFieldsAndBaseUriNonGlobalMapper
    implements IriTermMapper<IriWithNonConstructorFieldsAndBaseUriNonGlobal> {
  static final RegExp _regex = RegExp('^(?<myBaseUri>.*)/items/(?<id>[^/]*)\$');

  /// Provider for context variable 'myBaseUri'
  final String Function() _myBaseUriProvider;

  /// Constructor requiring providers for context variables
  const IriWithNonConstructorFieldsAndBaseUriNonGlobalMapper({
    required String Function() myBaseUriProvider,
  }) : _myBaseUriProvider = myBaseUriProvider;

  @override
  IriWithNonConstructorFieldsAndBaseUriNonGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final id = iriParts['id']!;

    final retval = IriWithNonConstructorFieldsAndBaseUriNonGlobal();
    retval.id = id;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithNonConstructorFieldsAndBaseUriNonGlobal resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = '{+myBaseUri}/items/{id}';
    iri = iri.replaceAll('{id}', resource.id.toString());
    iri = iri.replaceAll('{+myBaseUri}', _myBaseUriProvider());
    return IriTerm(iri);
  }
}

/// Generated mapper for [IriWithMixedFields] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithMixedFields.
class IriWithMixedFieldsMapper implements IriTermMapper<IriWithMixedFields> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/products/(?<brand>[^/]*)/(?<category>[^/]*)/(?<id>[^/]*)\$',
  );

  /// Constructor
  const IriWithMixedFieldsMapper();

  @override
  IriWithMixedFields fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = match == null
        ? <String, String>{}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );

    final brand = iriParts['brand']!;
    final id = iriParts['id']!;
    final productCategory = iriParts['category']!;

    final retval = IriWithMixedFields(brand: brand, id: id);
    retval.productCategory = productCategory;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithMixedFields resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    var iri = 'http://example.org/products/{brand}/{category}/{id}';
    iri = iri.replaceAll('{brand}', resource.brand.toString());
    iri = iri.replaceAll('{category}', resource.productCategory.toString());
    iri = iri.replaceAll('{id}', resource.id.toString());
    return IriTerm(iri);
  }
}
