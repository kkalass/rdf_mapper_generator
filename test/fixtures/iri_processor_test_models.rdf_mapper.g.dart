// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/iri_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'iri_processor_test_models.dart';

/// Generated mapper for [IriWithOnePart] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithOnePart.
class IriWithOnePartMapper implements IriTermMapper<IriWithOnePart> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/books/(?<isbn>[^/]*)\$',
  );

  /// Constructor
  const IriWithOnePartMapper();

  @override
  IriWithOnePart fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final isbn = iriParts['isbn']!;

    return IriWithOnePart(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePart iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final isbn = iriTermValue.isbn;
    return IriTerm('http://example.org/books/${isbn}');
  }
}

/// Generated mapper for [IriWithOnePartExplicitlyGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithOnePartExplicitlyGlobal.
class IriWithOnePartExplicitlyGlobalMapper
    implements IriTermMapper<IriWithOnePartExplicitlyGlobal> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/books/(?<isbn>[^/]*)\$',
  );

  /// Constructor
  const IriWithOnePartExplicitlyGlobalMapper();

  @override
  IriWithOnePartExplicitlyGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final isbn = iriParts['isbn']!;

    return IriWithOnePartExplicitlyGlobal(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePartExplicitlyGlobal iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final isbn = iriTermValue.isbn;
    return IriTerm('http://example.org/books/${isbn}');
  }
}

/// Generated mapper for [IriWithOnePartNamed] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithOnePartNamed.
class IriWithOnePartNamedMapper implements IriTermMapper<IriWithOnePartNamed> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/books/(?<isbn>[^/]*)\$',
  );

  /// Constructor
  const IriWithOnePartNamedMapper();

  @override
  IriWithOnePartNamed fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['isbn']!;

    return IriWithOnePartNamed(value: value);
  }

  @override
  IriTerm toRdfTerm(
    IriWithOnePartNamed iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    return IriTerm('http://example.org/books/${value}');
  }
}

/// Generated mapper for [IriWithTwoParts] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithTwoParts.
class IriWithTwoPartsMapper implements IriTermMapper<IriWithTwoParts> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/(?<type>[^/]*)/(?<value>[^/]*)\$',
  );

  /// Constructor
  const IriWithTwoPartsMapper();

  @override
  IriWithTwoParts fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['value']!;
    final type = iriParts['type']!;

    return IriWithTwoParts(value: value, type: type);
  }

  @override
  IriTerm toRdfTerm(
    IriWithTwoParts iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    final type = iriTermValue.type;
    return IriTerm('http://example.org/${type}/${value}');
  }
}

/// Generated mapper for [IriWithBaseUriAndTwoParts] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithBaseUriAndTwoParts.
class IriWithBaseUriAndTwoPartsMapper
    implements IriTermMapper<IriWithBaseUriAndTwoParts> {
  static final RegExp _regex = RegExp(
    '^(?<baseUri>.*)/(?<type>[^/]*)/(?<value>[^/]*)\$',
  );

  final String Function() _baseUriProvider;

  /// Constructor
  const IriWithBaseUriAndTwoPartsMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUriAndTwoParts fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final value = iriParts['value']!;
    final otherPart = iriParts['type']!;

    return IriWithBaseUriAndTwoParts(value: value, otherPart: otherPart);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUriAndTwoParts iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final value = iriTermValue.value;
    final otherPart = iriTermValue.otherPart;
    final baseUri = _baseUriProvider();
    return IriTerm('${baseUri}/${otherPart}/${value}');
  }
}

/// Generated mapper for [IriWithBaseUri] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithBaseUri.
class IriWithBaseUriMapper implements IriTermMapper<IriWithBaseUri> {
  static final RegExp _regex = RegExp('^(?<baseUri>.*)/books/(?<isbn>[^/]*)\$');

  final String Function() _baseUriProvider;

  /// Constructor
  const IriWithBaseUriMapper({required String Function() baseUriProvider})
    : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUri fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final isbn = iriParts['isbn']!;

    return IriWithBaseUri(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUri iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final isbn = iriTermValue.isbn;
    final baseUri = _baseUriProvider();
    return IriTerm('${baseUri}/books/${isbn}');
  }
}

/// Generated mapper for [IriWithBaseUriNoGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithBaseUriNoGlobal.
class IriWithBaseUriNoGlobalMapper
    implements IriTermMapper<IriWithBaseUriNoGlobal> {
  static final RegExp _regex = RegExp('^(?<baseUri>.*)/books/(?<isbn>[^/]*)\$');

  final String Function() _baseUriProvider;

  /// Constructor
  const IriWithBaseUriNoGlobalMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriWithBaseUriNoGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final isbn = iriParts['isbn']!;

    return IriWithBaseUriNoGlobal(isbn: isbn);
  }

  @override
  IriTerm toRdfTerm(
    IriWithBaseUriNoGlobal iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final isbn = iriTermValue.isbn;
    final baseUri = _baseUriProvider();
    return IriTerm('${baseUri}/books/${isbn}');
  }
}

/// Generated mapper for [IriWithNonConstructorFields] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithNonConstructorFields.
class IriWithNonConstructorFieldsMapper
    implements IriTermMapper<IriWithNonConstructorFields> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/items/(?<id>[^/]*)\$',
  );

  /// Constructor
  const IriWithNonConstructorFieldsMapper();

  @override
  IriWithNonConstructorFields fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final id = iriParts['id']!;

    final retval = IriWithNonConstructorFields();
    retval.id = id;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithNonConstructorFields iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final id = iriTermValue.id;
    return IriTerm('http://example.org/items/${id}');
  }
}

/// Generated mapper for [IriWithNonConstructorFieldsAndBaseUriNonGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithNonConstructorFieldsAndBaseUriNonGlobal.
class IriWithNonConstructorFieldsAndBaseUriNonGlobalMapper
    implements IriTermMapper<IriWithNonConstructorFieldsAndBaseUriNonGlobal> {
  static final RegExp _regex = RegExp('^(?<myBaseUri>.*)/items/(?<id>[^/]*)\$');

  final String Function() _myBaseUriProvider;

  /// Constructor
  const IriWithNonConstructorFieldsAndBaseUriNonGlobalMapper({
    required String Function() myBaseUriProvider,
  }) : _myBaseUriProvider = myBaseUriProvider;

  @override
  IriWithNonConstructorFieldsAndBaseUriNonGlobal fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final id = iriParts['id']!;

    final retval = IriWithNonConstructorFieldsAndBaseUriNonGlobal();
    retval.id = id;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithNonConstructorFieldsAndBaseUriNonGlobal iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final id = iriTermValue.id;
    final myBaseUri = _myBaseUriProvider();
    return IriTerm('${myBaseUri}/items/${id}');
  }
}

/// Generated mapper for [IriWithMixedFields] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type IriWithMixedFields.
class IriWithMixedFieldsMapper implements IriTermMapper<IriWithMixedFields> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/products/(?<brand>[^/]*)/(?<category>[^/]*)/(?<id>[^/]*)\$',
  );

  /// Constructor
  const IriWithMixedFieldsMapper();

  @override
  IriWithMixedFields fromRdfTerm(IriTerm term, DeserializationContext context) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.iri);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final brand = iriParts['brand']!;
    final id = iriParts['id']!;
    final productCategory = iriParts['category']!;

    final retval = IriWithMixedFields(brand: brand, id: id);
    retval.productCategory = productCategory;
    return retval;
  }

  @override
  IriTerm toRdfTerm(
    IriWithMixedFields iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final brand = iriTermValue.brand;
    final productCategory = iriTermValue.productCategory;
    final id = iriTermValue.id;
    return IriTerm(
      'http://example.org/products/${brand}/${productCategory}/${id}',
    );
  }
}
