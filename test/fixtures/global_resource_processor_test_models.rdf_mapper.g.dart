// GENERATED CODE - DO NOT MODIFY BY HAND
// 
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/global_resource_processor_test_models.dart
// Generated on: 2025-06-03T17:01:02.045441

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';
import 'package:rdf_vocabularies/schema.dart';
import 'global_resource_processor_test_models.dart';

/// Generated mapper for [Book] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type Book.
class BookMapper implements GlobalResourceMapper<Book> {

  /// Constructor
  const BookMapper();

  @override
  IriTerm get typeIri => SchemaBook.classIri;

  @override
  Book fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri, 'http://example.org/books/{isbn}', 
    ['isbn']);
    
    final isbn = iriParts['isbn'];
    final title = reader.optional<String>(SchemaBook.name) ?? null;
    final authorId = reader.optional<String>(SchemaBook.author) ?? null;

    return Book(
      isbn: isbn,
      title: title,
      authorId: authorId,
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Book resource) {
    var iri = 'http://example.org/books/{isbn}';
    iri = iri.replaceAll('{isbn}', resource.isbn.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(
      String iri, String template, List<String> variables) {
    // Convert template to regex pattern
    String regexPattern = RegExp.escape(template);

    // Replace variables with named capture groups
    for (final v in variables) {
      // Use named capture groups for cleaner variable extraction
      regexPattern = regexPattern
          .replaceAll('\\{\\+$v\\}', '(?<$v>.*)') // .* for +reserved expansion
          .replaceAll('\\{$v\\}', '(?<$v>[^/]*)'); // [^/]* for default
    }

    // Try to match the IRI against the regex pattern
    RegExp regex = RegExp('^$regexPattern\$');
    RegExpMatch? match = regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithEmptyIriStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithEmptyIriStrategy.
class ClassWithEmptyIriStrategyMapper implements GlobalResourceMapper<ClassWithEmptyIriStrategy> {

  /// Constructor
  const ClassWithEmptyIriStrategyMapper();

  @override
  IriTerm get typeIri => SchemaPerson.classIri;

  @override
  ClassWithEmptyIriStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = <String, String>{};
    

    return ClassWithEmptyIriStrategy(
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithEmptyIriStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm('');
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

}


/// Generated mapper for [ClassWithEmptyIriStrategyNoRegisterGlobally] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithEmptyIriStrategyNoRegisterGlobally.
class ClassWithEmptyIriStrategyNoRegisterGloballyMapper implements GlobalResourceMapper<ClassWithEmptyIriStrategyNoRegisterGlobally> {

  /// Constructor
  const ClassWithEmptyIriStrategyNoRegisterGloballyMapper();

  @override
  IriTerm get typeIri => SchemaPerson.classIri;

  @override
  ClassWithEmptyIriStrategyNoRegisterGlobally fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = <String, String>{};
    

    return ClassWithEmptyIriStrategyNoRegisterGlobally(
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithEmptyIriStrategyNoRegisterGlobally resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm('');
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

}


/// Generated mapper for [ClassWithIriTemplateStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriTemplateStrategy.
class ClassWithIriTemplateStrategyMapper implements GlobalResourceMapper<ClassWithIriTemplateStrategy> {

  /// Constructor
  const ClassWithIriTemplateStrategyMapper();

  @override
  IriTerm get typeIri => SchemaPerson.classIri;

  @override
  ClassWithIriTemplateStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri, 'http://example.org/persons/{id}', 
    ['id']);
    
    final id = iriParts['id'];

    return ClassWithIriTemplateStrategy(
      id: id,
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriTemplateStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithIriTemplateStrategy resource) {
    var iri = 'http://example.org/persons/{id}';
    iri = iri.replaceAll('{id}', resource.id.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(
      String iri, String template, List<String> variables) {
    // Convert template to regex pattern
    String regexPattern = RegExp.escape(template);

    // Replace variables with named capture groups
    for (final v in variables) {
      // Use named capture groups for cleaner variable extraction
      regexPattern = regexPattern
          .replaceAll('\\{\\+$v\\}', '(?<$v>.*)') // .* for +reserved expansion
          .replaceAll('\\{$v\\}', '(?<$v>[^/]*)'); // [^/]* for default
    }

    // Try to match the IRI against the regex pattern
    RegExp regex = RegExp('^$regexPattern\$');
    RegExpMatch? match = regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithIriTemplateAndContextVariableStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriTemplateAndContextVariableStrategy.
class ClassWithIriTemplateAndContextVariableStrategyMapper implements GlobalResourceMapper<ClassWithIriTemplateAndContextVariableStrategy> {
  /// Provider for context variable 'baseUri'
  final String Function() _baseUriProvider;

  /// Constructor requiring providers for context variables
  const ClassWithIriTemplateAndContextVariableStrategyMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriTerm get typeIri => SchemaPerson.classIri;

  @override
  ClassWithIriTemplateAndContextVariableStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri, '{+baseUri}/persons/{thisId}', 
    ['baseUri', 'thisId']);
    
    final id = iriParts['thisId'];

    return ClassWithIriTemplateAndContextVariableStrategy(
      id: id,
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriTemplateAndContextVariableStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithIriTemplateAndContextVariableStrategy resource) {
    var iri = '{+baseUri}/persons/{thisId}';
    iri = iri.replaceAll('{thisId}', resource.id.toString());
    iri = iri.replaceAll('{baseUri}', _baseUriProvider());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(
      String iri, String template, List<String> variables) {
    // Convert template to regex pattern
    String regexPattern = RegExp.escape(template);

    // Replace variables with named capture groups
    for (final v in variables) {
      // Use named capture groups for cleaner variable extraction
      regexPattern = regexPattern
          .replaceAll('\\{\\+$v\\}', '(?<$v>.*)') // .* for +reserved expansion
          .replaceAll('\\{$v\\}', '(?<$v>[^/]*)'); // [^/]* for default
    }

    // Try to match the IRI against the regex pattern
    RegExp regex = RegExp('^$regexPattern\$');
    RegExpMatch? match = regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithIriNamedMapperStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriNamedMapperStrategy.
class ClassWithIriNamedMapperStrategyMapper implements GlobalResourceMapper<ClassWithIriNamedMapperStrategy> {

  /// Constructor
  const ClassWithIriNamedMapperStrategyMapper();

  @override
  IriTerm get typeIri => SchemaPerson.classIri;

  @override
  ClassWithIriNamedMapperStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = <String, String>{};
    

    return ClassWithIriNamedMapperStrategy(
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriNamedMapperStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm('');
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

}


/// Generated mapper for [ClassWithIriMapperStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriMapperStrategy.
class ClassWithIriMapperStrategyMapper implements GlobalResourceMapper<ClassWithIriMapperStrategy> {

  /// Constructor
  const ClassWithIriMapperStrategyMapper();

  @override
  IriTerm get typeIri => SchemaPerson.classIri;

  @override
  ClassWithIriMapperStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = <String, String>{};
    

    return ClassWithIriMapperStrategy(
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriMapperStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm('');
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

}


/// Generated mapper for [ClassWithIriMapperInstanceStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriMapperInstanceStrategy.
class ClassWithIriMapperInstanceStrategyMapper implements GlobalResourceMapper<ClassWithIriMapperInstanceStrategy> {

  /// Constructor
  const ClassWithIriMapperInstanceStrategyMapper();

  @override
  IriTerm get typeIri => SchemaPerson.classIri;

  @override
  ClassWithIriMapperInstanceStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    
    // Extract IRI parts
    final iriParts = <String, String>{};
    

    return ClassWithIriMapperInstanceStrategy(
    );
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriMapperInstanceStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm('');
    
    final builder = context.resourceBuilder(subject);
    

    return builder.build();
  }

}


