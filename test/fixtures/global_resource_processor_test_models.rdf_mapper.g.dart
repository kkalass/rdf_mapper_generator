// GENERATED CODE - DO NOT MODIFY BY HAND
// 
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/global_resource_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'global_resource_processor_test_models.dart';
import 'package:rdf_vocabularies/schema.dart' as schema;

/// Generated mapper for [Book] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type Book.
class BookMapper implements GlobalResourceMapper<Book> {
  static final RegExp _regex = RegExp('^http://example\.org/books/(?<isbn>[^/]*)\$');


  /// Constructor
  const BookMapper();

  @override
  IriTerm? get typeIri => schema.SchemaBook.classIri;

  @override
  Book fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    

    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);
    
    final isbn = iriParts['isbn']!;
    final String title = reader.require(schema.SchemaBook.name);
    final String authorId = reader.require(schema.SchemaBook.author);

    final retval = Book(
      isbn: isbn,
      title: title,
      authorId: authorId
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    return context.resourceBuilder(subject)
      .addValue(schema.SchemaBook.name, resource.title)
      .addValue(schema.SchemaBook.author, resource.authorId)
      .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Book resource) {
    var iri = 'http://example.org/books/{isbn}';
    iri = iri.replaceAll('{isbn}', resource.isbn.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithEmptyIriStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithEmptyIriStrategy.
class ClassWithEmptyIriStrategyMapper implements GlobalResourceMapper<ClassWithEmptyIriStrategy> {
  static final RegExp _regex = RegExp('^(?<iri>.*)\$');


  /// Constructor
  const ClassWithEmptyIriStrategyMapper();

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithEmptyIriStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    

    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);
    
    final iri = iriParts['iri']!;

    final retval = ClassWithEmptyIriStrategy(
      iri: iri
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithEmptyIriStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    return context.resourceBuilder(subject)
      .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithEmptyIriStrategy resource) {
    var iri = '{+iri}';
    iri = iri.replaceAll('{+iri}', resource.iri.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithNoRdfType] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithNoRdfType.
class ClassWithNoRdfTypeMapper implements GlobalResourceMapper<ClassWithNoRdfType> {
  static final RegExp _regex = RegExp('^(?<iri>.*)\$');


  /// Constructor
  const ClassWithNoRdfTypeMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  ClassWithNoRdfType fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    

    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);
    
    final String name = reader.require(schema.SchemaPerson.name);
    final int? age = reader.optional(schema.SchemaPerson.foafAge);
    final iri = iriParts['iri']!;

    final retval = ClassWithNoRdfType(
      name,
      age: age
    );
    retval.iri = iri;
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithNoRdfType resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    return context.resourceBuilder(subject)
      .addValue(schema.SchemaPerson.name, resource.name)
      .addValueIfNotNull(schema.SchemaPerson.foafAge, resource.age)
      .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithNoRdfType resource) {
    var iri = '{+iri}';
    iri = iri.replaceAll('{+iri}', resource.iri.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithEmptyIriStrategyNoRegisterGlobally] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithEmptyIriStrategyNoRegisterGlobally.
class ClassWithEmptyIriStrategyNoRegisterGloballyMapper implements GlobalResourceMapper<ClassWithEmptyIriStrategyNoRegisterGlobally> {
  static final RegExp _regex = RegExp('^(?<iri>.*)\$');


  /// Constructor
  const ClassWithEmptyIriStrategyNoRegisterGloballyMapper();

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithEmptyIriStrategyNoRegisterGlobally fromRdfResource(IriTerm subject, DeserializationContext context) {
    

    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);
    
    final iri = iriParts['iri']!;

    final retval = ClassWithEmptyIriStrategyNoRegisterGlobally(
      iri: iri
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithEmptyIriStrategyNoRegisterGlobally resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    return context.resourceBuilder(subject)
      .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithEmptyIriStrategyNoRegisterGlobally resource) {
    var iri = '{+iri}';
    iri = iri.replaceAll('{+iri}', resource.iri.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithIriTemplateStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriTemplateStrategy.
class ClassWithIriTemplateStrategyMapper implements GlobalResourceMapper<ClassWithIriTemplateStrategy> {
  static final RegExp _regex = RegExp('^http://example\.org/persons/(?<id>[^/]*)\$');


  /// Constructor
  const ClassWithIriTemplateStrategyMapper();

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriTemplateStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    

    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);
    
    final id = iriParts['id']!;

    final retval = ClassWithIriTemplateStrategy(
      id: id
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriTemplateStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    return context.resourceBuilder(subject)
      .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithIriTemplateStrategy resource) {
    var iri = 'http://example.org/persons/{id}';
    iri = iri.replaceAll('{id}', resource.id.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithIriTemplateAndContextVariableStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriTemplateAndContextVariableStrategy.
class ClassWithIriTemplateAndContextVariableStrategyMapper implements GlobalResourceMapper<ClassWithIriTemplateAndContextVariableStrategy> {
  static final RegExp _regex = RegExp('^(?<baseUri>.*)/persons/(?<thisId>[^/]*)\$');
  /// Provider for context variable 'baseUri'
  final String Function() _baseUriProvider;


  /// Constructor requiring providers for context variables
  const ClassWithIriTemplateAndContextVariableStrategyMapper({
    
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriTemplateAndContextVariableStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    

    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);
    
    final id = iriParts['thisId']!;

    final retval = ClassWithIriTemplateAndContextVariableStrategy(
      id: id
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriTemplateAndContextVariableStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));
    
    return context.resourceBuilder(subject)
      .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithIriTemplateAndContextVariableStrategy resource) {
    var iri = '{+baseUri}/persons/{thisId}';
    iri = iri.replaceAll('{thisId}', resource.id.toString());
    iri = iri.replaceAll('{+baseUri}', _baseUriProvider());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(match.groupNames.map((name) {
            var namedGroup = match.namedGroup(name)!;
            return MapEntry(name, namedGroup);
          }));
  }
}


/// Generated mapper for [ClassWithIriNamedMapperStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriNamedMapperStrategy.
class ClassWithIriNamedMapperStrategyMapper implements GlobalResourceMapper<ClassWithIriNamedMapperStrategy> {

  final IriTermMapper<ClassWithIriNamedMapperStrategy> _iriMapper;

  /// Constructor
  const ClassWithIriNamedMapperStrategyMapper({
    required IriTermMapper<ClassWithIriNamedMapperStrategy> iriMapper
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriNamedMapperStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    

    // Extract IRI parts
    

    final retval = ClassWithIriNamedMapperStrategy(
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriNamedMapperStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm(resource, context);
    
    return context.resourceBuilder(subject)
      .build();
  }

}


/// Generated mapper for [ClassWithIriMapperStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriMapperStrategy.
class ClassWithIriMapperStrategyMapper implements GlobalResourceMapper<ClassWithIriMapperStrategy> {

  final IriTermMapper<ClassWithIriMapperStrategy> _iriMapper;

  /// Constructor
  const ClassWithIriMapperStrategyMapper({
    required IriTermMapper<ClassWithIriMapperStrategy> iriMapper
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriMapperStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    

    // Extract IRI parts
    

    final retval = ClassWithIriMapperStrategy(
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriMapperStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm(resource, context);
    
    return context.resourceBuilder(subject)
      .build();
  }

}


/// Generated mapper for [ClassWithIriMapperInstanceStrategy] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriMapperInstanceStrategy.
class ClassWithIriMapperInstanceStrategyMapper implements GlobalResourceMapper<ClassWithIriMapperInstanceStrategy> {

  final IriTermMapper<ClassWithIriMapperInstanceStrategy> _iriMapper;

  /// Constructor
  const ClassWithIriMapperInstanceStrategyMapper({
    required IriTermMapper<ClassWithIriMapperInstanceStrategy> iriMapper
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriMapperInstanceStrategy fromRdfResource(IriTerm subject, DeserializationContext context) {
    

    // Extract IRI parts
    

    final retval = ClassWithIriMapperInstanceStrategy(
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriMapperInstanceStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm(resource, context);
    
    return context.resourceBuilder(subject)
      .build();
  }

}


