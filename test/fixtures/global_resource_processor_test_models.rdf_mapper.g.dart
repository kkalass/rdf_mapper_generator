// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/global_resource_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'global_resource_processor_test_models.dart';
import 'package:rdf_vocabularies/schema.dart' as schema;

/// Generated mapper for [Book] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type Book.
class BookMapper implements GlobalResourceMapper<Book> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/books/(?<isbn>[^/]*)\$',
  );

  /// Constructor
  const BookMapper();

  @override
  IriTerm? get typeIri => schema.SchemaBook.classIri;

  @override
  Book fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);

    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);

    final isbn = iriParts['isbn']!;
    final String title = reader.require(schema.SchemaBook.name);
    final String authorId = reader.require(schema.SchemaBook.author);

    final retval = Book(isbn: isbn, title: title, authorId: authorId);
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    Book resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(schema.SchemaBook.name, resource.title)
        .addValue(schema.SchemaBook.author, resource.authorId)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(Book resource) {
    var iri = 'http://example.org/books/{isbn}';
    iri = iri.replaceAll('{isbn}', resource.isbn.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );
  }
}

/// Generated mapper for [ClassWithEmptyIriStrategy] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithEmptyIriStrategy.
class ClassWithEmptyIriStrategyMapper
    implements GlobalResourceMapper<ClassWithEmptyIriStrategy> {
  static final RegExp _regex = RegExp('^(?<iri>.*)\$');

  /// Constructor
  const ClassWithEmptyIriStrategyMapper();

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithEmptyIriStrategy fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);

    final iri = iriParts['iri']!;

    final retval = ClassWithEmptyIriStrategy(iri: iri);
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithEmptyIriStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context.resourceBuilder(subject).build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithEmptyIriStrategy resource) {
    var iri = '{+iri}';
    iri = iri.replaceAll('{+iri}', resource.iri.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );
  }
}

/// Generated mapper for [ClassWithNoRdfType] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithNoRdfType.
class ClassWithNoRdfTypeMapper
    implements GlobalResourceMapper<ClassWithNoRdfType> {
  static final RegExp _regex = RegExp('^(?<iri>.*)\$');

  /// Constructor
  const ClassWithNoRdfTypeMapper();

  @override
  IriTerm? get typeIri => null;

  @override
  ClassWithNoRdfType fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);

    final String name = reader.require(schema.SchemaPerson.name);
    final int? age = reader.optional(schema.SchemaPerson.foafAge);
    final iri = iriParts['iri']!;

    final retval = ClassWithNoRdfType(name, age: age);
    retval.iri = iri;
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithNoRdfType resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(schema.SchemaPerson.name, resource.name)
        .addValueIfNotNull(schema.SchemaPerson.foafAge, resource.age)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithNoRdfType resource) {
    var iri = '{+iri}';
    iri = iri.replaceAll('{+iri}', resource.iri.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );
  }
}

/// Generated mapper for [ClassWithEmptyIriStrategyNoRegisterGlobally] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithEmptyIriStrategyNoRegisterGlobally.
class ClassWithEmptyIriStrategyNoRegisterGloballyMapper
    implements
        GlobalResourceMapper<ClassWithEmptyIriStrategyNoRegisterGlobally> {
  static final RegExp _regex = RegExp('^(?<iri>.*)\$');

  /// Constructor
  const ClassWithEmptyIriStrategyNoRegisterGloballyMapper();

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithEmptyIriStrategyNoRegisterGlobally fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);

    final iri = iriParts['iri']!;

    final retval = ClassWithEmptyIriStrategyNoRegisterGlobally(iri: iri);
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithEmptyIriStrategyNoRegisterGlobally resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context.resourceBuilder(subject).build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithEmptyIriStrategyNoRegisterGlobally resource) {
    var iri = '{+iri}';
    iri = iri.replaceAll('{+iri}', resource.iri.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );
  }
}

/// Generated mapper for [ClassWithIriTemplateStrategy] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriTemplateStrategy.
class ClassWithIriTemplateStrategyMapper
    implements GlobalResourceMapper<ClassWithIriTemplateStrategy> {
  static final RegExp _regex = RegExp(
    '^http://example\.org/persons/(?<id>[^/]*)\$',
  );

  /// Constructor
  const ClassWithIriTemplateStrategyMapper();

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriTemplateStrategy fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);

    final id = iriParts['id']!;

    final retval = ClassWithIriTemplateStrategy(id: id);
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriTemplateStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context.resourceBuilder(subject).build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithIriTemplateStrategy resource) {
    var iri = 'http://example.org/persons/{id}';
    iri = iri.replaceAll('{id}', resource.id.toString());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );
  }
}

/// Generated mapper for [ClassWithIriTemplateAndContextVariableStrategy] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriTemplateAndContextVariableStrategy.
class ClassWithIriTemplateAndContextVariableStrategyMapper
    implements
        GlobalResourceMapper<ClassWithIriTemplateAndContextVariableStrategy> {
  static final RegExp _regex = RegExp(
    '^(?<baseUri>.*)/persons/(?<thisId>[^/]*)\$',
  );

  /// Provider for context variable 'baseUri'
  final String Function() _baseUriProvider;

  /// Constructor requiring providers for context variables
  const ClassWithIriTemplateAndContextVariableStrategyMapper({
    required String Function() baseUriProvider,
  }) : _baseUriProvider = baseUriProvider;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriTemplateAndContextVariableStrategy fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);

    final id = iriParts['thisId']!;

    final retval = ClassWithIriTemplateAndContextVariableStrategy(id: id);
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriTemplateAndContextVariableStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context.resourceBuilder(subject).build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithIriTemplateAndContextVariableStrategy resource) {
    var iri = '{+baseUri}/persons/{thisId}';
    iri = iri.replaceAll('{thisId}', resource.id.toString());
    iri = iri.replaceAll('{+baseUri}', _baseUriProvider());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );
  }
}

/// Generated mapper for [ClassWithOtherBaseUriNonGlobal] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithOtherBaseUriNonGlobal.
class ClassWithOtherBaseUriNonGlobalMapper
    implements GlobalResourceMapper<ClassWithOtherBaseUriNonGlobal> {
  static final RegExp _regex = RegExp(
    '^(?<otherBaseUri>.*)/persons/(?<thisId>[^/]*)\$',
  );

  /// Provider for context variable 'otherBaseUri'
  final String Function() _otherBaseUriProvider;

  /// Constructor requiring providers for context variables
  const ClassWithOtherBaseUriNonGlobalMapper({
    required String Function() otherBaseUriProvider,
  }) : _otherBaseUriProvider = otherBaseUriProvider;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithOtherBaseUriNonGlobal fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts
    final iriParts = _parseIriParts(subject.iri);

    final id = iriParts['thisId']!;

    final retval = ClassWithOtherBaseUriNonGlobal(id: id);
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithOtherBaseUriNonGlobal resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = IriTerm(_buildIri(resource));

    return context.resourceBuilder(subject).build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(ClassWithOtherBaseUriNonGlobal resource) {
    var iri = '{+otherBaseUri}/persons/{thisId}';
    iri = iri.replaceAll('{thisId}', resource.id.toString());
    iri = iri.replaceAll('{+otherBaseUri}', _otherBaseUriProvider());
    return iri;
  }

  /// Parses IRI parts from a complete IRI using a template.
  ///
  /// Supports RFC 6570 URI Template standard:
  /// - {variable} (default): excludes reserved characters like '/'
  /// - {+variable}: includes reserved characters for URLs/paths (RFC 6570 Level 2)
  Map<String, String> _parseIriParts(String iri) {
    // Try to match the IRI against the regex pattern
    RegExpMatch? match = _regex.firstMatch(iri);

    return match == null
        ? {}
        : Map.fromEntries(
            match.groupNames.map((name) {
              var namedGroup = match.namedGroup(name)!;
              return MapEntry(name, namedGroup);
            }),
          );
  }
}

/// Generated mapper for [ClassWithIriNamedMapperStrategy] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriNamedMapperStrategy.
class ClassWithIriNamedMapperStrategyMapper
    implements GlobalResourceMapper<ClassWithIriNamedMapperStrategy> {
  final IriTermMapper<ClassWithIriNamedMapperStrategy> _iriMapper;

  /// Constructor
  const ClassWithIriNamedMapperStrategyMapper({
    required IriTermMapper<ClassWithIriNamedMapperStrategy> iriMapper,
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriNamedMapperStrategy fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts

    final retval = ClassWithIriNamedMapperStrategy();
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriNamedMapperStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm(resource, context);

    return context.resourceBuilder(subject).build();
  }
}

/// Generated mapper for [ClassWithIriNamedMapperStrategy1Part] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriNamedMapperStrategy1Part.
class ClassWithIriNamedMapperStrategy1PartMapper
    implements GlobalResourceMapper<ClassWithIriNamedMapperStrategy1Part> {
  final IriTermMapper<(String id,)> _iriMapper;

  /// Constructor
  const ClassWithIriNamedMapperStrategy1PartMapper({
    required IriTermMapper<(String id,)> iriMapper,
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriNamedMapperStrategy1Part fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts
    final (id,) = _iriMapper.fromRdfTerm(subject, context);

    final retval = ClassWithIriNamedMapperStrategy1Part(id: id);
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriNamedMapperStrategy1Part resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm((resource.id,), context);

    return context.resourceBuilder(subject).build();
  }
}

/// Generated mapper for [ClassWithIriNamedMapperStrategy2Parts] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriNamedMapperStrategy2Parts.
class ClassWithIriNamedMapperStrategy2PartsMapper
    implements GlobalResourceMapper<ClassWithIriNamedMapperStrategy2Parts> {
  final IriTermMapper<(String id, int version)> _iriMapper;

  /// Constructor
  const ClassWithIriNamedMapperStrategy2PartsMapper({
    required IriTermMapper<(String id, int version)> iriMapper,
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriNamedMapperStrategy2Parts fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts
    final (id, version) = _iriMapper.fromRdfTerm(subject, context);

    final retval = ClassWithIriNamedMapperStrategy2Parts(
      id: id,
      version: version,
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriNamedMapperStrategy2Parts resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm((
      resource.id,
      resource.version,
    ), context);

    return context.resourceBuilder(subject).build();
  }
}

/// Generated mapper for [ClassWithIriNamedMapperStrategy2PartsSwapped] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriNamedMapperStrategy2PartsSwapped.
class ClassWithIriNamedMapperStrategy2PartsSwappedMapper
    implements
        GlobalResourceMapper<ClassWithIriNamedMapperStrategy2PartsSwapped> {
  final IriTermMapper<(int version, String id)> _iriMapper;

  /// Constructor
  const ClassWithIriNamedMapperStrategy2PartsSwappedMapper({
    required IriTermMapper<(int version, String id)> iriMapper,
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriNamedMapperStrategy2PartsSwapped fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts
    final (version, id) = _iriMapper.fromRdfTerm(subject, context);

    final retval = ClassWithIriNamedMapperStrategy2PartsSwapped(
      id: id,
      version: version,
    );
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriNamedMapperStrategy2PartsSwapped resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm((
      resource.version,
      resource.id,
    ), context);

    return context.resourceBuilder(subject).build();
  }
}

/// Generated mapper for [ClassWithIriNamedMapperStrategy2PartsWithProperties] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriNamedMapperStrategy2PartsWithProperties.
class ClassWithIriNamedMapperStrategy2PartsWithPropertiesMapper
    implements
        GlobalResourceMapper<
          ClassWithIriNamedMapperStrategy2PartsWithProperties
        > {
  final IriTermMapper<(String id, String surname, int version)> _iriMapper;

  /// Constructor
  const ClassWithIriNamedMapperStrategy2PartsWithPropertiesMapper({
    required IriTermMapper<(String id, String surname, int version)> iriMapper,
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriNamedMapperStrategy2PartsWithProperties fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    // Extract IRI parts
    final (id, _, version) = _iriMapper.fromRdfTerm(subject, context);

    final String givenName = reader.require(schema.SchemaPerson.givenName);
    final String surname = reader.require(schema.SchemaPerson.foafSurname);
    final int? age = reader.optional(schema.SchemaPerson.foafAge);

    final retval = ClassWithIriNamedMapperStrategy2PartsWithProperties();
    retval.id = id;
    retval.version = version;
    retval.givenName = givenName;
    retval.surname = surname;
    retval.age = age;
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriNamedMapperStrategy2PartsWithProperties resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm((
      resource.id,
      resource.surname,
      resource.version,
    ), context);

    return context
        .resourceBuilder(subject)
        .addValue(schema.SchemaPerson.givenName, resource.givenName)
        .addValue(schema.SchemaPerson.foafSurname, resource.surname)
        .addValueIfNotNull(schema.SchemaPerson.foafAge, resource.age)
        .build();
  }
}

/// Generated mapper for [ClassWithIriMapperStrategy] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriMapperStrategy.
class ClassWithIriMapperStrategyMapper
    implements GlobalResourceMapper<ClassWithIriMapperStrategy> {
  final IriTermMapper<ClassWithIriMapperStrategy> _iriMapper;

  /// Constructor
  const ClassWithIriMapperStrategyMapper({
    required IriTermMapper<ClassWithIriMapperStrategy> iriMapper,
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriMapperStrategy fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    // Extract IRI parts

    final retval = ClassWithIriMapperStrategy();
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriMapperStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm(resource, context);

    return context.resourceBuilder(subject).build();
  }
}

/// Generated mapper for [ClassWithIriMapperInstanceStrategy] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type ClassWithIriMapperInstanceStrategy.
class ClassWithIriMapperInstanceStrategyMapper
    implements GlobalResourceMapper<ClassWithIriMapperInstanceStrategy> {
  final IriTermMapper<ClassWithIriMapperInstanceStrategy> _iriMapper;

  /// Constructor
  const ClassWithIriMapperInstanceStrategyMapper({
    required IriTermMapper<ClassWithIriMapperInstanceStrategy> iriMapper,
  }) : _iriMapper = iriMapper;

  @override
  IriTerm? get typeIri => schema.SchemaPerson.classIri;

  @override
  ClassWithIriMapperInstanceStrategy fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    // Extract IRI parts

    final String name = reader.require(schema.SchemaPerson.name);

    final retval = ClassWithIriMapperInstanceStrategy(name: name);
    return retval;
  }

  @override
  (IriTerm, List<Triple>) toRdfResource(
    ClassWithIriMapperInstanceStrategy resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = _iriMapper.toRdfTerm(resource, context);

    return context
        .resourceBuilder(subject)
        .addValue(schema.SchemaPerson.name, resource.name)
        .build();
  }
}
