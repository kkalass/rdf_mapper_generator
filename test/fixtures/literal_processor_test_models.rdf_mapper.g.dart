// GENERATED CODE - DO NOT MODIFY BY HAND
// 
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/literal_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'literal_processor_test_models.dart';
import 'package:rdf_vocabularies/rdf.dart' as rdf;
import 'package:rdf_vocabularies/xsd.dart' as xsd;

/// Generated mapper for [LiteralString] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralString.
class LiteralStringMapper implements LiteralTermMapper<LiteralString> {

  const LiteralStringMapper();

  @override
  LiteralString fromRdfTerm(LiteralTerm term, DeserializationContext context,{bool bypassDatatypeCheck=false}) {
    return LiteralString(
      foo: context.fromLiteralTerm(term, bypassDatatypeCheck: bypassDatatypeCheck)
      );
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralString value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.foo);
  }
}


/// Generated mapper for [Rating] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Rating.
class RatingMapper implements LiteralTermMapper<Rating> {

  const RatingMapper();

  @override
  Rating fromRdfTerm(LiteralTerm term, DeserializationContext context,{bool bypassDatatypeCheck=false}) {
    return Rating(
      context.fromLiteralTerm(term, bypassDatatypeCheck: bypassDatatypeCheck)
      );
  }

  @override
  LiteralTerm toRdfTerm(
    Rating value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.stars);
  }
}


/// Generated mapper for [LocalizedText] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LocalizedText.
class LocalizedTextMapper implements LiteralTermMapper<LocalizedText> {

  const LocalizedTextMapper();

  @override
  LocalizedText fromRdfTerm(LiteralTerm term, DeserializationContext context,{bool bypassDatatypeCheck=false}) {
    if (!bypassDatatypeCheck && term.datatype != rdf.Rdf.langString) {
      throw DeserializerDatatypeMismatchException(
          'Failed to parse LocalizedText: ${term.value}. ',
          actual: term.datatype,
          expected: rdf.Rdf.langString,
          targetType: LocalizedText,
          mapperRuntimeType: this.runtimeType);
    }
    return LocalizedText(
      context.fromLiteralTerm(term, bypassDatatypeCheck: true /*we handle the actual final datatype ourselves, just delegate for convenience*/),
            term.language!
      );
  }

  @override
  LiteralTerm toRdfTerm(
    LocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm.withLanguage(context.toLiteralTerm(value.text).value, value.language);
  }
}


/// Generated mapper for [LiteralDouble] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralDouble.
class LiteralDoubleMapper implements LiteralTermMapper<LiteralDouble> {

  const LiteralDoubleMapper();

  @override
  LiteralDouble fromRdfTerm(LiteralTerm term, DeserializationContext context,{bool bypassDatatypeCheck=false}) {
    if (!bypassDatatypeCheck && term.datatype != xsd.Xsd.double) {
      throw DeserializerDatatypeMismatchException(
          'Failed to parse LiteralDouble: ${term.value}. ',
          actual: term.datatype,
          expected: xsd.Xsd.double,
          targetType: LiteralDouble,
          mapperRuntimeType: this.runtimeType);
    }
    return LiteralDouble(
      foo: context.fromLiteralTerm(term, bypassDatatypeCheck: true /*we handle the actual final datatype ourselves, just delegate for convenience*/)
      );
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralDouble value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm(context.toLiteralTerm(value.foo).value, datatype: xsd.Xsd.double);
  }
}


/// Generated mapper for [LiteralInteger] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralInteger.
class LiteralIntegerMapper implements LiteralTermMapper<LiteralInteger> {

  const LiteralIntegerMapper();

  @override
  LiteralInteger fromRdfTerm(LiteralTerm term, DeserializationContext context,{bool bypassDatatypeCheck=false}) {
    if (!bypassDatatypeCheck && term.datatype != xsd.Xsd.integer) {
      throw DeserializerDatatypeMismatchException(
          'Failed to parse LiteralInteger: ${term.value}. ',
          actual: term.datatype,
          expected: xsd.Xsd.integer,
          targetType: LiteralInteger,
          mapperRuntimeType: this.runtimeType);
    }
    return LiteralInteger(
      value: context.fromLiteralTerm(term, bypassDatatypeCheck: true /*we handle the actual final datatype ourselves, just delegate for convenience*/)
      );
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralInteger value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm(context.toLiteralTerm(value.value).value, datatype: xsd.Xsd.integer);
  }
}


/// Generated mapper for [Temperature] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Temperature.
class TemperatureMapper implements LiteralTermMapper<Temperature> {

  const TemperatureMapper();

  @override
  Temperature fromRdfTerm(LiteralTerm term, DeserializationContext context,{bool bypassDatatypeCheck=false}) {
    return Temperature.parse(term);
  }

  @override
  LiteralTerm toRdfTerm(
    Temperature value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.formatCelsius();
  }
}


/// Generated mapper for [CustomLocalizedText] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type CustomLocalizedText.
class CustomLocalizedTextMapper implements LiteralTermMapper<CustomLocalizedText> {

  const CustomLocalizedTextMapper();

  @override
  CustomLocalizedText fromRdfTerm(LiteralTerm term, DeserializationContext context,{bool bypassDatatypeCheck=false}) {
    return CustomLocalizedText.fromRdf(term);
  }

  @override
  LiteralTerm toRdfTerm(
    CustomLocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.toRdf();
  }
}


/// Generated mapper for [DoubleAsMilliunit] global resources.
/// 
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type DoubleAsMilliunit.
class DoubleAsMilliunitMapper implements LiteralTermMapper<DoubleAsMilliunit> {

  const DoubleAsMilliunitMapper();

  @override
  DoubleAsMilliunit fromRdfTerm(LiteralTerm term, DeserializationContext context,{bool bypassDatatypeCheck=false}) {
    return DoubleAsMilliunit.fromMilliunit(term);
  }

  @override
  LiteralTerm toRdfTerm(
    DoubleAsMilliunit value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.toMilliunit();
  }
}


