// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/literal_processor_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'literal_processor_test_models.dart';
import 'package:rdf_vocabularies/rdf.dart' as rdf;
import 'package:rdf_vocabularies/xsd.dart';

/// Generated mapper for [LiteralString] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralString.
class LiteralStringMapper implements LiteralTermMapper<LiteralString> {
  const LiteralStringMapper();

  @override
  LiteralString fromRdfTerm(LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    final String foo =
        context.fromLiteralTerm(term, bypassDatatypeCheck: bypassDatatypeCheck);

    return LiteralString(foo: foo);
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralString value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.foo);
  }
}

/// Generated mapper for [Rating] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Rating.
class RatingMapper implements LiteralTermMapper<Rating> {
  const RatingMapper();

  @override
  Rating fromRdfTerm(LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    final int stars =
        context.fromLiteralTerm(term, bypassDatatypeCheck: bypassDatatypeCheck);

    return Rating(stars);
  }

  @override
  LiteralTerm toRdfTerm(
    Rating value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.stars);
  }
}

/// Generated mapper for [LocalizedText] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LocalizedText.
class LocalizedTextMapper implements LiteralTermMapper<LocalizedText> {
  const LocalizedTextMapper();

  @override
  LocalizedText fromRdfTerm(LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    if (!bypassDatatypeCheck && term.datatype != rdf.Rdf.langString) {
      throw DeserializerDatatypeMismatchException(
          'Failed to parse LocalizedText: ${term.value}. ',
          actual: term.datatype,
          expected: rdf.Rdf.langString,
          targetType: LocalizedText,
          mapperRuntimeType: this.runtimeType);
    }
    final String text = context.fromLiteralTerm(term,
        bypassDatatypeCheck:
            true /*we handle the actual final datatype ourselves, just delegate for convenience*/);
    final String language = term.language!;

    return LocalizedText(text, language);
  }

  @override
  LiteralTerm toRdfTerm(
    LocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm.withLanguage(
        context.toLiteralTerm(value.text).value, value.language);
  }
}

/// Generated mapper for [LiteralDouble] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralDouble.
class LiteralDoubleMapper implements LiteralTermMapper<LiteralDouble> {
  const LiteralDoubleMapper();

  @override
  LiteralDouble fromRdfTerm(LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.double) {
      throw DeserializerDatatypeMismatchException(
          'Failed to parse LiteralDouble: ${term.value}. ',
          actual: term.datatype,
          expected: Xsd.double,
          targetType: LiteralDouble,
          mapperRuntimeType: this.runtimeType);
    }
    final double foo = context.fromLiteralTerm(term,
        bypassDatatypeCheck:
            true /*we handle the actual final datatype ourselves, just delegate for convenience*/);

    return LiteralDouble(foo: foo);
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralDouble value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm(context.toLiteralTerm(value.foo).value,
        datatype: Xsd.double);
  }
}

/// Generated mapper for [LiteralInteger] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralInteger.
class LiteralIntegerMapper implements LiteralTermMapper<LiteralInteger> {
  const LiteralIntegerMapper();

  @override
  LiteralInteger fromRdfTerm(LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.integer) {
      throw DeserializerDatatypeMismatchException(
          'Failed to parse LiteralInteger: ${term.value}. ',
          actual: term.datatype,
          expected: Xsd.integer,
          targetType: LiteralInteger,
          mapperRuntimeType: this.runtimeType);
    }
    final int value = context.fromLiteralTerm(term,
        bypassDatatypeCheck:
            true /*we handle the actual final datatype ourselves, just delegate for convenience*/);

    return LiteralInteger(value: value);
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralInteger value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm(context.toLiteralTerm(value.value).value,
        datatype: Xsd.integer);
  }
}

/// Generated mapper for [Temperature] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type Temperature.
class TemperatureMapper implements LiteralTermMapper<Temperature> {
  const TemperatureMapper();

  @override
  Temperature fromRdfTerm(LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    return Temperature.parse(term);
  }

  @override
  LiteralTerm toRdfTerm(
    Temperature value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.formatCelsius();
  }
}

/// Generated mapper for [CustomLocalizedText] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type CustomLocalizedText.
class CustomLocalizedTextMapper
    implements LiteralTermMapper<CustomLocalizedText> {
  const CustomLocalizedTextMapper();

  @override
  CustomLocalizedText fromRdfTerm(
      LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    return CustomLocalizedText.fromRdf(term);
  }

  @override
  LiteralTerm toRdfTerm(
    CustomLocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.toRdf();
  }
}

/// Generated mapper for [DoubleAsMilliunit] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type DoubleAsMilliunit.
class DoubleAsMilliunitMapper implements LiteralTermMapper<DoubleAsMilliunit> {
  const DoubleAsMilliunitMapper();

  @override
  DoubleAsMilliunit fromRdfTerm(
      LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    return DoubleAsMilliunit.fromMilliunit(term);
  }

  @override
  LiteralTerm toRdfTerm(
    DoubleAsMilliunit value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return value.toMilliunit();
  }
}

/// Generated mapper for [LiteralWithNonConstructorValue] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralWithNonConstructorValue.
class LiteralWithNonConstructorValueMapper
    implements LiteralTermMapper<LiteralWithNonConstructorValue> {
  const LiteralWithNonConstructorValueMapper();

  @override
  LiteralWithNonConstructorValue fromRdfTerm(
      LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    final String value =
        context.fromLiteralTerm(term, bypassDatatypeCheck: bypassDatatypeCheck);

    final retval = LiteralWithNonConstructorValue();
    retval.value = value;
    return retval;
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralWithNonConstructorValue value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context.toLiteralTerm(value.value);
  }
}

/// Generated mapper for [LocalizedTextWithNonConstructorLanguage] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LocalizedTextWithNonConstructorLanguage.
class LocalizedTextWithNonConstructorLanguageMapper
    implements LiteralTermMapper<LocalizedTextWithNonConstructorLanguage> {
  const LocalizedTextWithNonConstructorLanguageMapper();

  @override
  LocalizedTextWithNonConstructorLanguage fromRdfTerm(
      LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    if (!bypassDatatypeCheck && term.datatype != rdf.Rdf.langString) {
      throw DeserializerDatatypeMismatchException(
          'Failed to parse LocalizedTextWithNonConstructorLanguage: ${term.value}. ',
          actual: term.datatype,
          expected: rdf.Rdf.langString,
          targetType: LocalizedTextWithNonConstructorLanguage,
          mapperRuntimeType: this.runtimeType);
    }
    final String text = context.fromLiteralTerm(term,
        bypassDatatypeCheck:
            true /*we handle the actual final datatype ourselves, just delegate for convenience*/);
    final String language = term.language!;

    final retval = LocalizedTextWithNonConstructorLanguage(text);
    retval.language = language;
    return retval;
  }

  @override
  LiteralTerm toRdfTerm(
    LocalizedTextWithNonConstructorLanguage value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm.withLanguage(
        context.toLiteralTerm(value.text).value, value.language);
  }
}

/// Generated mapper for [LiteralLateFinalLocalizedText] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type LiteralLateFinalLocalizedText.
class LiteralLateFinalLocalizedTextMapper
    implements LiteralTermMapper<LiteralLateFinalLocalizedText> {
  const LiteralLateFinalLocalizedTextMapper();

  @override
  LiteralLateFinalLocalizedText fromRdfTerm(
      LiteralTerm term, DeserializationContext context,
      {bool bypassDatatypeCheck = false}) {
    if (!bypassDatatypeCheck && term.datatype != rdf.Rdf.langString) {
      throw DeserializerDatatypeMismatchException(
          'Failed to parse LiteralLateFinalLocalizedText: ${term.value}. ',
          actual: term.datatype,
          expected: rdf.Rdf.langString,
          targetType: LiteralLateFinalLocalizedText,
          mapperRuntimeType: this.runtimeType);
    }
    final String baseValue = context.fromLiteralTerm(term,
        bypassDatatypeCheck:
            true /*we handle the actual final datatype ourselves, just delegate for convenience*/);
    final String language = term.language!;

    final retval = LiteralLateFinalLocalizedText();
    retval.baseValue = baseValue;
    retval.language = language;
    return retval;
  }

  @override
  LiteralTerm toRdfTerm(
    LiteralLateFinalLocalizedText value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm.withLanguage(
        context.toLiteralTerm(value.baseValue).value, value.language);
  }
}
