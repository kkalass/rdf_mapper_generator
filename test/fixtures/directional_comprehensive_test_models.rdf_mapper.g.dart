// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/directional_comprehensive_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'directional_comprehensive_test_models.dart';
import 'package:rdf_vocabularies_core/xsd.dart';
import 'package:rdf_vocabularies_core/rdf.dart' as rdf;

/// Generated mapper for [DeserializeOnlyGlobalResource] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `DeserializeOnlyGlobalResource`.
class DeserializeOnlyGlobalResourceMapper
    implements GlobalResourceDeserializer<DeserializeOnlyGlobalResource> {
  /// Constructor
  const DeserializeOnlyGlobalResourceMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('http://example.org/DeserializeOnlyClass');

  @override
  DeserializeOnlyGlobalResource fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String name = reader.require(
      const IriTerm('http://example.org/name'),
    );

    return DeserializeOnlyGlobalResource(name: name);
  }
}

/// Generated mapper for [SerializeOnlyGlobalResource] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `SerializeOnlyGlobalResource`.
class SerializeOnlyGlobalResourceMapper
    implements GlobalResourceSerializer<SerializeOnlyGlobalResource> {
  /// Constructor
  const SerializeOnlyGlobalResourceMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('http://example.org/SerializeOnlyClass');

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    SerializeOnlyGlobalResource resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(const IriTerm('http://example.org/title'), resource.title)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(SerializeOnlyGlobalResource resource) {
    final id = resource.id;
    return 'http://example.org/items/${id}';
  }
}

/// Generated mapper for [BidirectionalGlobalResource] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `BidirectionalGlobalResource`.
class BidirectionalGlobalResourceMapper
    implements GlobalResourceMapper<BidirectionalGlobalResource> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/bidirectional/(?<id>[^/]*)$',
  );

  /// Constructor
  const BidirectionalGlobalResourceMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('http://example.org/BidirectionalClass');

  @override
  BidirectionalGlobalResource fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String description = reader.require(
      const IriTerm('http://example.org/description'),
    );

    return BidirectionalGlobalResource(id: id, description: description);
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    BidirectionalGlobalResource resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://example.org/description'),
          resource.description,
        )
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(BidirectionalGlobalResource resource) {
    final id = resource.id;
    return 'http://example.org/bidirectional/${id}';
  }
}

/// Generated mapper for [DeserializeOnlyLocalResource] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `DeserializeOnlyLocalResource`.
class DeserializeOnlyLocalResourceMapper
    implements LocalResourceDeserializer<DeserializeOnlyLocalResource> {
  /// Constructor
  const DeserializeOnlyLocalResourceMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('http://example.org/LocalDeserializeOnly');

  @override
  DeserializeOnlyLocalResource fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String localName = reader.require(
      const IriTerm('http://example.org/localName'),
    );

    return DeserializeOnlyLocalResource(localName: localName);
  }
}

/// Generated mapper for [SerializeOnlyLocalResource] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `SerializeOnlyLocalResource`.
class SerializeOnlyLocalResourceMapper
    implements LocalResourceSerializer<SerializeOnlyLocalResource> {
  /// Constructor
  const SerializeOnlyLocalResourceMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('http://example.org/LocalSerializeOnly');

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    SerializeOnlyLocalResource resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://example.org/localTitle'),
          resource.localTitle,
        )
        .build();
  }
}

/// Generated mapper for [BidirectionalLocalResource] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `BidirectionalLocalResource`.
class BidirectionalLocalResourceMapper
    implements LocalResourceMapper<BidirectionalLocalResource> {
  /// Constructor
  const BidirectionalLocalResourceMapper();

  @override
  IriTerm? get typeIri =>
      const IriTerm('http://example.org/LocalBidirectional');

  @override
  BidirectionalLocalResource fromRdfResource(
    BlankNodeTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final String localDescription = reader.require(
      const IriTerm('http://example.org/localDescription'),
    );

    return BidirectionalLocalResource(localDescription: localDescription);
  }

  @override
  (BlankNodeTerm, Iterable<Triple>) toRdfResource(
    BidirectionalLocalResource resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = BlankNodeTerm();

    return context
        .resourceBuilder(subject)
        .addValue(
          const IriTerm('http://example.org/localDescription'),
          resource.localDescription,
        )
        .build();
  }
}

/// Generated mapper for [DeserializeOnlyIriClass] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `DeserializeOnlyIriClass`.
class DeserializeOnlyIriClassMapper
    implements IriTermDeserializer<DeserializeOnlyIriClass> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/iri/deserialize/(?<id>[^/]*)$',
  );

  /// Constructor
  const DeserializeOnlyIriClassMapper();

  @override
  DeserializeOnlyIriClass fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${term.value}',
      );
    }

    return DeserializeOnlyIriClass(id: id);
  }
}

/// Generated mapper for [SerializeOnlyIriClass] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `SerializeOnlyIriClass`.
class SerializeOnlyIriClassMapper
    implements IriTermSerializer<SerializeOnlyIriClass> {
  /// Constructor
  const SerializeOnlyIriClassMapper();

  @override
  IriTerm toRdfTerm(
    SerializeOnlyIriClass iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final code = iriTermValue.code;
    return context.createIriTerm('http://example.org/iri/serialize/${code}');
  }
}

/// Generated mapper for [BidirectionalIriClass] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type `BidirectionalIriClass`.
class BidirectionalIriClassMapper
    implements IriTermMapper<BidirectionalIriClass> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/iri/bidirectional/(?<uuid>[^/]*)$',
  );

  /// Constructor
  const BidirectionalIriClassMapper();

  @override
  BidirectionalIriClass fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    final iriParts = {
      for (var name in match?.groupNames ?? const <String>[])
        name: match?.namedGroup(name) ?? '',
    };
    final uuid = iriParts['uuid'];
    if (uuid == null) {
      throw DeserializationException(
        'Missing required IRI part: uuid in IRI ${term.value}',
      );
    }

    return BidirectionalIriClass(uuid: uuid);
  }

  @override
  IriTerm toRdfTerm(
    BidirectionalIriClass iriTermValue,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final uuid = iriTermValue.uuid;
    return context.createIriTerm(
      'http://example.org/iri/bidirectional/${uuid}',
    );
  }
}

/// Generated mapper for [DeserializeOnlyLiteralClass] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type DeserializeOnlyLiteralClass.
class DeserializeOnlyLiteralClassMapper
    implements LiteralTermDeserializer<DeserializeOnlyLiteralClass> {
  final IriTerm? datatype = Xsd.string;

  const DeserializeOnlyLiteralClassMapper();

  @override
  DeserializeOnlyLiteralClass fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.string) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse DeserializeOnlyLiteralClass: ${term.value}. ',
        actual: term.datatype,
        expected: Xsd.string,
        targetType: DeserializeOnlyLiteralClass,
        mapperRuntimeType: this.runtimeType,
      );
    }
    final String value = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck:
          true /*we handle the actual final datatype ourselves, just delegate for convenience*/,
    );

    return DeserializeOnlyLiteralClass(value: value);
  }
}

/// Generated mapper for [SerializeOnlyLiteralClass] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type SerializeOnlyLiteralClass.
class SerializeOnlyLiteralClassMapper
    implements LiteralTermSerializer<SerializeOnlyLiteralClass> {
  final IriTerm? datatype = Xsd.integer;

  const SerializeOnlyLiteralClassMapper();

  @override
  LiteralTerm toRdfTerm(
    SerializeOnlyLiteralClass value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm(
      context.toLiteralTerm(value.value).value,
      datatype: Xsd.integer,
    );
  }
}

/// Generated mapper for [BidirectionalLiteralClass] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF terms for iri terms of type BidirectionalLiteralClass.
class BidirectionalLiteralClassMapper
    implements LiteralTermMapper<BidirectionalLiteralClass> {
  final IriTerm? datatype = Xsd.boolean;

  const BidirectionalLiteralClassMapper();

  @override
  BidirectionalLiteralClass fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.boolean) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse BidirectionalLiteralClass: ${term.value}. ',
        actual: term.datatype,
        expected: Xsd.boolean,
        targetType: BidirectionalLiteralClass,
        mapperRuntimeType: this.runtimeType,
      );
    }
    final bool value = context.fromLiteralTerm(
      term,
      bypassDatatypeCheck:
          true /*we handle the actual final datatype ourselves, just delegate for convenience*/,
    );

    return BidirectionalLiteralClass(value: value);
  }

  @override
  LiteralTerm toRdfTerm(
    BidirectionalLiteralClass value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return LiteralTerm(
      context.toLiteralTerm(value.value).value,
      datatype: Xsd.boolean,
    );
  }
}

/// Generated mapper for [DeserializeOnlyIriEnum] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type DeserializeOnlyIriEnum.
class DeserializeOnlyIriEnumMapper
    implements IriTermDeserializer<DeserializeOnlyIriEnum> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/enum/priority/(?<value>[^/]*)$',
  );

  /// Constructor
  const DeserializeOnlyIriEnumMapper();

  @override
  DeserializeOnlyIriEnum fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException(
        'Unknown DeserializeOnlyIriEnum IRI: ${term.value}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'high' => DeserializeOnlyIriEnum.high,
      'medium' => DeserializeOnlyIriEnum.medium,
      'low' => DeserializeOnlyIriEnum.low,
      _ => throw DeserializationException(
        'Unknown DeserializeOnlyIriEnum IRI: ${term.value}',
      ),
    };
  }
}

/// Generated mapper for [SerializeOnlyIriEnum] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type SerializeOnlyIriEnum.
class SerializeOnlyIriEnumMapper
    implements IriTermSerializer<SerializeOnlyIriEnum> {
  /// Constructor
  const SerializeOnlyIriEnumMapper();

  @override
  IriTerm toRdfTerm(
    SerializeOnlyIriEnum value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    SerializeOnlyIriEnum.active => context.createIriTerm(_buildIri('active')),
    SerializeOnlyIriEnum.inactive => context.createIriTerm(
      _buildIri('inactive'),
    ),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://example.org/enum/status/${value}';
  }
}

/// Generated mapper for [BidirectionalIriEnum] enum IRIs.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF IRI terms for enum type BidirectionalIriEnum.
class BidirectionalIriEnumMapper
    implements IriTermMapper<BidirectionalIriEnum> {
  static final RegExp _regex = RegExp(
    r'^http://example\.org/enum/type/(?<value>[^/]*)$',
  );

  /// Constructor
  const BidirectionalIriEnumMapper();

  @override
  BidirectionalIriEnum fromRdfTerm(
    IriTerm term,
    DeserializationContext context,
  ) {
    /// Parses IRI parts from a complete IRI using a template.
    final RegExpMatch? match = _regex.firstMatch(term.value);

    if (match == null) {
      throw DeserializationException(
        'Unknown BidirectionalIriEnum IRI: ${term.value}',
      );
    }

    final iriParts = {
      for (var name in match.groupNames) name: match.namedGroup(name) ?? '',
    };
    final enumValue = iriParts['value'];
    if (enumValue == null) {
      throw DeserializationException(
        'Missing required IRI part: value in IRI ${term.value}',
      );
    }

    return switch (enumValue) {
      'typeA' => BidirectionalIriEnum.typeA,
      'typeB' => BidirectionalIriEnum.typeB,
      _ => throw DeserializationException(
        'Unknown BidirectionalIriEnum IRI: ${term.value}',
      ),
    };
  }

  @override
  IriTerm toRdfTerm(
    BidirectionalIriEnum value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    BidirectionalIriEnum.typeA => context.createIriTerm(_buildIri('typeA')),
    BidirectionalIriEnum.typeB => context.createIriTerm(_buildIri('typeB')),
  };

  /// Generates the complete IRI for a given enum value
  String _buildIri(String value) {
    return 'http://example.org/enum/type/${value}';
  }
}

/// Generated mapper for [DeserializeOnlyLiteralEnum] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type DeserializeOnlyLiteralEnum.
class DeserializeOnlyLiteralEnumMapper
    implements LiteralTermDeserializer<DeserializeOnlyLiteralEnum> {
  final IriTerm? datatype = Xsd.string;

  const DeserializeOnlyLiteralEnumMapper();

  @override
  DeserializeOnlyLiteralEnum fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.string) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse DeserializeOnlyLiteralEnum: ${term.value}. ',
        actual: term.datatype,
        expected: Xsd.string,
        targetType: DeserializeOnlyLiteralEnum,
        mapperRuntimeType: this.runtimeType,
      );
    }
    return switch (term.value) {
      'option1' => DeserializeOnlyLiteralEnum.option1,
      'option2' => DeserializeOnlyLiteralEnum.option2,
      _ => throw DeserializationException(
        'Unknown DeserializeOnlyLiteralEnum literal value: ${term.value}',
      ),
    };
  }
}

/// Generated mapper for [SerializeOnlyLiteralEnum] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type SerializeOnlyLiteralEnum.
class SerializeOnlyLiteralEnumMapper
    implements LiteralTermSerializer<SerializeOnlyLiteralEnum> {
  final IriTerm? datatype = Xsd.string;

  const SerializeOnlyLiteralEnumMapper();

  @override
  LiteralTerm toRdfTerm(
    SerializeOnlyLiteralEnum value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    SerializeOnlyLiteralEnum.choiceA => LiteralTerm(
      'choiceA',
      datatype: Xsd.string,
    ),
    SerializeOnlyLiteralEnum.choiceB => LiteralTerm(
      'choiceB',
      datatype: Xsd.string,
    ),
  };
}

/// Generated mapper for [BidirectionalLiteralEnum] enum literals.
///
/// This mapper handles serialization and deserialization between enum constants
/// and RDF literal terms for enum type BidirectionalLiteralEnum.
class BidirectionalLiteralEnumMapper
    implements LiteralTermMapper<BidirectionalLiteralEnum> {
  final IriTerm? datatype = Xsd.string;

  const BidirectionalLiteralEnumMapper();

  @override
  BidirectionalLiteralEnum fromRdfTerm(
    LiteralTerm term,
    DeserializationContext context, {
    bool bypassDatatypeCheck = false,
  }) {
    if (!bypassDatatypeCheck && term.datatype != Xsd.string) {
      throw DeserializerDatatypeMismatchException(
        'Failed to parse BidirectionalLiteralEnum: ${term.value}. ',
        actual: term.datatype,
        expected: Xsd.string,
        targetType: BidirectionalLiteralEnum,
        mapperRuntimeType: this.runtimeType,
      );
    }
    return switch (term.value) {
      'valueX' => BidirectionalLiteralEnum.valueX,
      'valueY' => BidirectionalLiteralEnum.valueY,
      _ => throw DeserializationException(
        'Unknown BidirectionalLiteralEnum literal value: ${term.value}',
      ),
    };
  }

  @override
  LiteralTerm toRdfTerm(
    BidirectionalLiteralEnum value,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) => switch (value) {
    BidirectionalLiteralEnum.valueX => LiteralTerm(
      'valueX',
      datatype: Xsd.string,
    ),
    BidirectionalLiteralEnum.valueY => LiteralTerm(
      'valueY',
      datatype: Xsd.string,
    ),
  };
}
