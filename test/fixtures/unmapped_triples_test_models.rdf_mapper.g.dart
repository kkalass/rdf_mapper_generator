// GENERATED CODE - DO NOT MODIFY BY HAND
//
// This file was generated by the RDF Mapper Generator.
// Source: test/fixtures/unmapped_triples_test_models.dart

// ignore_for_file: unused_import, unnecessary_cast, prefer_const_constructors
// ignore_for_file: unnecessary_brace_in_string_interps, prefer_conditional_assignment
// ignore_for_file: lines_longer_than_80_chars, avoid_redundant_argument_values
// ignore_for_file: unused_field, unnecessary_string_interpolations

import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';

// Other imports
import 'unmapped_triples_test_models.dart';
import 'package:rdf_vocabularies_schema/schema.dart';

/// Generated mapper for [BookWithUnmappedTriples] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `BookWithUnmappedTriples`.
class BookWithUnmappedTriplesMapper
    implements GlobalResourceMapper<BookWithUnmappedTriples> {
  static final RegExp _regex = RegExp(
    r'^https://example\.org/books/(?<id>[^/]*)$',
  );

  /// Constructor
  const BookWithUnmappedTriplesMapper();

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  BookWithUnmappedTriples fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(SchemaBook.name);
    final String author = reader.require(SchemaBook.author);

    // Get unmapped triples as the last reader operation for lossless mapping
    final RdfGraph unmappedTriples = reader.getUnmapped<RdfGraph>();

    return BookWithUnmappedTriples(
      id: id,
      title: title,
      author: author,
      unmappedTriples: unmappedTriples,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    BookWithUnmappedTriples resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addValue(SchemaBook.author, resource.author)
        .addUnmapped(resource.unmappedTriples)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(BookWithUnmappedTriples resource) {
    final id = resource.id;
    return 'https://example.org/books/${id}';
  }
}

/// Generated mapper for [BookWithUnmappedTriplesLateFields] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `BookWithUnmappedTriplesLateFields`.
class BookWithUnmappedTriplesLateFieldsMapper
    implements GlobalResourceMapper<BookWithUnmappedTriplesLateFields> {
  static final RegExp _regex = RegExp(
    r'^https://example\.org/books/(?<id>[^/]*)$',
  );

  /// Constructor
  const BookWithUnmappedTriplesLateFieldsMapper();

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  BookWithUnmappedTriplesLateFields fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(SchemaBook.name);
    final String author = reader.require(SchemaBook.author);

    // Get unmapped triples as the last reader operation for lossless mapping
    final RdfGraph unmappedTriples = reader.getUnmapped<RdfGraph>();

    final retval = BookWithUnmappedTriplesLateFields();
    retval.id = id;
    retval.title = title;
    retval.author = author;
    retval.unmappedTriples = unmappedTriples;
    return retval;
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    BookWithUnmappedTriplesLateFields resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addValue(SchemaBook.author, resource.author)
        .addUnmapped(resource.unmappedTriples)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(BookWithUnmappedTriplesLateFields resource) {
    final id = resource.id;
    return 'https://example.org/books/${id}';
  }
}

/// Generated mapper for [BookWithInvalidUnmappedTriplesType] global resources.
///
/// This mapper handles serialization and deserialization between Dart objects
/// and RDF triples for resources of type `BookWithInvalidUnmappedTriplesType`.
class BookWithInvalidUnmappedTriplesTypeMapper
    implements GlobalResourceMapper<BookWithInvalidUnmappedTriplesType> {
  static final RegExp _regex = RegExp(
    r'^https://example\.org/books/(?<id>[^/]*)$',
  );

  /// Constructor
  const BookWithInvalidUnmappedTriplesTypeMapper();

  @override
  IriTerm? get typeIri => SchemaBook.classIri;

  @override
  BookWithInvalidUnmappedTriplesType fromRdfResource(
    IriTerm subject,
    DeserializationContext context,
  ) {
    final reader = context.reader(subject);

    final RegExpMatch? match = _regex.firstMatch(subject.value);

    final iriParts = {
      for (var name in (match?.groupNames ?? const <String>[]))
        name: match?.namedGroup(name) ?? '',
    };

    final id = iriParts['id'];
    if (id == null) {
      throw DeserializationException(
        'Missing required IRI part: id in IRI ${subject.value}',
      );
    }
    final String title = reader.require(SchemaBook.name);

    // Get unmapped triples as the last reader operation for lossless mapping
    final String invalidField = reader.getUnmapped<String>();

    return BookWithInvalidUnmappedTriplesType(
      id: id,
      title: title,
      invalidField: invalidField,
    );
  }

  @override
  (IriTerm, Iterable<Triple>) toRdfResource(
    BookWithInvalidUnmappedTriplesType resource,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    final subject = context.createIriTerm(_buildIri(resource));

    return context
        .resourceBuilder(subject)
        .addValue(SchemaBook.name, resource.title)
        .addUnmapped(resource.invalidField)
        .build();
  }

  /// Builds the IRI for a resource instance using the IRI template.
  String _buildIri(BookWithInvalidUnmappedTriplesType resource) {
    final id = resource.id;
    return 'https://example.org/books/${id}';
  }
}
